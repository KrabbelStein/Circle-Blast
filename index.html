<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Circle Blast</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #0b0b0f;
  font-family: system-ui;
  color: white;
}

#game {
  position: fixed;
  inset: 0;
}

.ui {
  position: absolute;
  top: 12px;
  left: 12px;
  z-index: 10;
  display: flex;
  gap: 10px;
}

.panel {
  background: rgba(0,0,0,0.5);
  padding: 10px 14px;
  border-radius: 10px;
  display: flex;
  gap: 12px;
  align-items: center;
}
button {
  cursor: pointer;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
</head>

<body>
<div id="game"></div>

<div class="ui">
  <div class="panel">
    <div id="score">Punkte: 0</div>
    <div id="timer">30s</div>
    <button id="start">Start</button>
    <button id="reset">Reset</button>
  </div>
</div>

<script>
let score = 0;
let timeRemaining = 30;
let running = false;

let spawnEvent = null;
let timerEvent = null;

const MAX_CIRCLES = 8;

const config = {
  type: Phaser.AUTO,
  parent: 'game',
  width: window.innerWidth,
  height: window.innerHeight,
  backgroundColor: '#0b0b0f',
  scale: {
    mode: Phaser.Scale.RESIZE,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  scene: { create }
};

const game = new Phaser.Game(config);

function create() {
  const scene = this;
  scene.circles = scene.add.group();

  const scoreEl = document.getElementById('score');
  const timerEl = document.getElementById('timer');

  function spawnCircle() {
    if (!running) return;
    if (scene.circles.getLength() >= MAX_CIRCLES) return;

    const size = Phaser.Math.RND.pick([50,70,90]);
    const half = size / 2;

    const x = Phaser.Math.Between(half, scene.scale.width - half);
    const y = Phaser.Math.Between(half + 44, scene.scale.height - half - 60);

    const g = scene.add.graphics();
    g.fillStyle(Phaser.Display.Color.RandomRGB().color, 0.6);
    g.fillCircle(0, 0, half);
    g.x = x;
    g.y = y;
    g.size = size;
    g.spawnTime = performance.now();
    g.isHit = false;

    g.setInteractive(new Phaser.Geom.Circle(0,0,half), Phaser.Geom.Circle.Contains);

    g.on('pointerdown', () => {
      if (g.isHit) return;
      g.isHit = true;

      const reaction = (performance.now() - g.spawnTime) / 1000;
      const bonus = Math.round(7 * Math.max(0, 1 - reaction / 2));
      score += 10 + bonus;
      scoreEl.textContent = 'Punkte: ' + score;

      scene.tweens.add({
        targets: g,
        x: scene.scale.width / 2,
        y: scene.scale.height / 2,
        scale: 0,
        duration: 300,
        ease: 'Cubic.easeIn',
        onComplete: () => {
          scene.circles.remove(g);
          g.destroy();
        }
      });
    });

    scene.circles.add(g);
  }

  function startGame() {
    if (running) return;

    running = true;
    score = 0;
    timeRemaining = 30;
    scoreEl.textContent = 'Punkte: 0';
    timerEl.textContent = '30s';

    scene.circles.clear(true, true);

    spawnCircle(); // â˜… exakt EIN Kreis beim Start

    spawnEvent = scene.time.addEvent({
      delay: 1200,
      loop: true,
      callback: spawnCircle
    });

    timerEvent = scene.time.addEvent({
      delay: 1000,
      loop: true,
      callback: () => {
        timeRemaining--;
        timerEl.textContent = timeRemaining + 's';
        if (timeRemaining <= 0) endGame();
      }
    });
  }

  function endGame() {
    if (!running) return;
    running = false;

    spawnEvent?.remove();
    timerEvent?.remove();

    scene.circles.getChildren().forEach(c => c.destroy());
    scene.circles.clear();
  }

  function resetGame() {
    endGame();
    score = 0;
    timeRemaining = 30;
    scoreEl.textContent = 'Punkte: 0';
    timerEl.textContent = '30s';
  }

  document.getElementById('start').onclick = startGame;
  document.getElementById('reset').onclick = resetGame;

  window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
  });
}
</script>
</body>
</html>
