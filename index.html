<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Circle Blast</title>
  <meta name="description" content="Circle Blast — kleines Browsergame. Klicke Kreise an, sammle Punkte und Highscores." />
  <style>
    :root{
      --bg:#0b0b0f; --panel:#111217; --muted:rgba(255,255,255,0.08); --accent:#3b82f6;
      --glass: rgba(255,255,255,0.03);
      --radius:10px;
      --ui-padding:10px;
      --font: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:var(--font);-webkit-font-smoothing:antialiased}
    #game-container{width:100%;height:100vh;position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center}
    .ui { position:absolute; top:12px; left:12px; z-index:30; display:flex; gap:8px; align-items:center; flex-wrap:wrap; background:transparent; }
    .panel { background:var(--panel); border-radius:var(--radius); padding:var(--ui-padding); display:flex; gap:8px; align-items:center; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
    .btn { background:linear-gradient(180deg,#1f2937,#111827); color:#fff; border:1px solid rgba(255,255,255,0.04); padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
    .btn.ghost { background:transparent; border:1px solid var(--muted); padding:6px 10px; font-weight:600; }
    .score, .highscore { background:var(--glass); padding:8px 12px; border-radius:8px; font-weight:700; }
    .center-msg { position:absolute; z-index:20; color:#ddd; text-align:center; pointer-events:none; left:50%; transform:translateX(-50%); top:36vh; }
    .bottom-right { position:absolute; right:12px; bottom:12px; z-index:20; color:#ddd; font-size:13px; opacity:0.9; }
    .small { font-size:13px; opacity:0.9; }
    @media (max-width:520px){
      .panel{padding:8px}
      .score,.highscore{padding:6px 8px}
      .btn{padding:6px 8px}
    }
  </style>

  <!-- Phaser 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game-container"></div>

  <div class="ui" aria-hidden="true">
    <div class="panel">
      <div class="score" id="score">Score: 0</div>
      <div class="highscore" id="highscore">Highscore: 0</div>
      <button class="btn" id="startBtn">Start</button>
      <button class="btn ghost" id="resetBtn">Reset</button>
      <button class="btn ghost" id="resetHighBtn" title="Highscore löschen">Reset HS</button>
      <button class="btn ghost" id="soundToggle">Sound On</button>
    </div>
  </div>

  <div class="center-msg" id="centerMsg" role="status" aria-live="polite">
    <h1 style="margin:0 0 8px 0">Circle Blast</h1>
    <div style="opacity:0.85">Klicke Kreise an, um Punkte zu sammeln</div>
  </div>

  <div class="bottom-right small" id="info">Tip: Klick Start</div>

  <script>
    // Konfiguration
    const STORAGE_KEY = 'circle-blast-highscore-v2';
    const MAX_CIRCLES = 6;
    const SPAWN_INTERVAL = 1400; // ms
    const SPAWN_ATTEMPTS = 12;
    const PARTICLE_LIMIT = 12; // max particles per blast (vernünftig begrenzt)

    // Phaser Setup
    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      width: Math.min(960, window.innerWidth),
      height: Math.min(640, window.innerHeight),
      backgroundColor: '#0b0b0f',
      physics: { default: 'arcade', arcade: { debug: false } },
      scene: { preload, create, update }
    };

    let game = new Phaser.Game(config);
    let score = 0;
    let scoreEl, highEl, centerMsg, infoEl, soundOn = true;
    let spawnTimer = 0;
    let running = false;

    function preload() {
      // Erzeuge eine kleine Partikel-Textur einmalig (wiederverwendbar)
      this.load.once('complete', () => {}, this);
      // optionaler Sound (wenn verfügbar)
      try {
        this.load.audio('pop', 'https://cdn.jsdelivr.net/gh/kripken/sound-effects/pop.mp3');
      } catch (e) { /* ignore */ }
    }

    function create() {
      const scene = this;
      scoreEl = document.getElementById('score');
      highEl = document.getElementById('highscore');
      centerMsg = document.getElementById('centerMsg');
      infoEl = document.getElementById('info');

      updateHighscoreDisplay(loadHighscore());

      this.circles = this.physics.add.group();

      // Erzeuge einmalig eine kleine Partikel-Textur (6x6)
      const g = this.add.graphics();
      g.fillStyle(0xffffff, 1);
      g.fillCircle(3, 3, 3);
      g.generateTexture('particleDot', 6, 6);
      g.destroy();

      // Input: Klick / Touch (koordinatenbasiert)
      this.input.on('pointerdown', function (pointer) {
        if (!running) return;
        const x = pointer.x;
        const y = pointer.y;
        const hit = scene.circles.getChildren().find(c => {
          const dx = c.x - x;
          const dy = c.y - y;
          return Math.sqrt(dx*dx + dy*dy) <= c.displayWidth/2;
        });
        if (hit) blastCircle(scene, hit);
      });

      // Buttons
      document.getElementById('startBtn').addEventListener('click', () => {
        if (!running) startGame(scene);
      });
      document.getElementById('resetBtn').addEventListener('click', () => {
        resetGame(scene);
      });
      document.getElementById('resetHighBtn').addEventListener('click', () => {
        resetHighscore();
        infoEl.textContent = 'Highscore zurückgesetzt';
        setTimeout(()=> infoEl.textContent = 'Tip: Klick Start', 1600);
      });
      document.getElementById('soundToggle').addEventListener('click', (e) => {
        soundOn = !soundOn;
        e.target.textContent = soundOn ? 'Sound On' : 'Sound Off';
      });

      // Responsive resize
      window.addEventListener('resize', () => {
        scene.scale.resize(Math.min(960, window.innerWidth), Math.min(640, window.innerHeight));
      });

      // kurze Anleitung
      setTimeout(() => { centerMsg.style.opacity = 0.95; }, 200);
      setTimeout(() => { centerMsg.style.opacity = 0.6; }, 4000);
    }

    function update(time, delta) {
      if (!running) return;
      spawnTimer += delta;
      if (spawnTimer > SPAWN_INTERVAL) {
        spawnTimer = 0;
        if (this.circles.getLength() < MAX_CIRCLES) {
          spawnCircle(this);
        }
        removeOldCircles(this);
      }
      // Kreise bleiben statisch bis zum Klick
    }

    function loadHighscore() {
      const v = localStorage.getItem(STORAGE_KEY);
      return v ? parseInt(v, 10) : 0;
    }
    function saveHighscore(value) {
      localStorage.setItem(STORAGE_KEY, String(value));
    }
    function resetHighscore() {
      localStorage.removeItem(STORAGE_KEY);
      updateHighscoreDisplay(0);
    }
    function updateHighscoreDisplay(value) {
      if (highEl) highEl.textContent = 'Highscore: ' + value;
    }

    function spawnCircle(scene) {
      const size = Phaser.Math.Between(28, 64);
      let chosen = null;

      for (let i=0;i<SPAWN_ATTEMPTS;i++) {
        const half = Math.round(size / 2);
        const x = Phaser.Math.Between(half, scene.scale.width - half);
        const y = Phaser.Math.Between(half + 44, scene.scale.height - half - 60);
        const overlaps = scene.circles.getChildren().some(existing => {
          const dx = existing.x - x;
          const dy = existing.y - y;
          const minDist = (existing.displayWidth + size) * 0.5 + 8;
          return (dx*dx + dy*dy) < (minDist * minDist);
        });
        if (!overlaps) { chosen = {x,y}; break; }
      }

      if (!chosen) return; // no free spot found

      const color = Phaser.Display.Color.RandomRGB();
      const gfx = scene.add.graphics();
      // draw circle centered in texture to avoid quarter-circle bug
      gfx.fillStyle(color.color, 1);
      gfx.fillCircle(Math.round(size/2), Math.round(size/2), Math.round(size/2));
      const textureKey = 'circle' + Phaser.Math.RND.uuid();
      gfx.generateTexture(textureKey, size, size);
      gfx.destroy();

      const sprite = scene.add.image(chosen.x, chosen.y, textureKey);
      sprite.setDisplaySize(size, size);
      sprite.setOrigin(0.5, 0.5);
      scene.physics.world.enable(sprite);
      if (sprite.body && sprite.body.setCircle) {
        sprite.body.setCircle(Math.round(size/2));
      }
      // mark as not interactive (we use coordinate hit test)
      scene.circles.add(sprite);

      // auto remove after time (clean remove from group)
      scene.time.delayedCall(Phaser.Math.Between(6000, 10000), () => {
        if (sprite && sprite.active) {
          scene.circles.remove(sprite, true, true);
        }
      });
    }

    function removeOldCircles(scene) {
      // Entferne älteste, falls zu viele
      while (scene.circles.getLength() > MAX_CIRCLES) {
        const oldest = scene.circles.getChildren()[0];
        if (oldest) {
          scene.circles.remove(oldest, true, true);
        } else break;
      }
    }

    function blastCircle(scene, sprite) {
      // Prevent double-trigger on same sprite: deactivate immediately
      try {
        sprite.active = false;
        if (sprite.body && sprite.body.enable) sprite.body.enable = false;
      } catch (e) { /* ignore */ }

      const size = sprite.displayWidth;

      // Punkte: kleinere Kreise geben mehr Punkte
      const pts = Math.max(5, Math.round(80 - size));
      score += pts;
      if (scoreEl) scoreEl.textContent = 'Score: ' + score;

      // update highscore
      const currentHigh = loadHighscore();
      if (score > currentHigh) {
        saveHighscore(score);
        updateHighscoreDisplay(score);
        infoEl.textContent = 'Neuer Highscore!';
        setTimeout(()=> infoEl.textContent = 'Tip: Klick Start', 1200);
      }

      // Tween: zur Mitte bewegen und schrumpfen (scaleX/scaleY)
      const centerX = scene.scale.width / 2;
      const centerY = scene.scale.height / 2;

      // Kill any tweens targeting this sprite to avoid conflicts
      scene.tweens.killTweensOf(sprite);

      scene.tweens.add({
        targets: sprite,
        x: centerX,
        y: centerY,
        scaleX: 0.05,
        scaleY: 0.05,
        duration: 320,
        ease: 'Cubic.easeIn',
        onComplete: () => {
          // Partikel: benutze die vorerzeugte 'particleDot' Textur
          const particles = scene.add.particles('particleDot');
          const emitter = particles.createEmitter({
            x: centerX, y: centerY,
            speed: { min: 80, max: 220 },
            angle: { min: 0, max: 360 },
            lifespan: 400,
            quantity: Math.min(8, PARTICLE_LIMIT),
            scale: { start: 1.0, end: 0 },
            blendMode: 'ADD'
          });

          // kurze Verzögerung, dann Partikel entfernen und Sprite zerstören
          scene.time.delayedCall(300, () => {
            try {
              particles.destroy();
            } catch (e) { /* ignore */ }
            // Entferne sauber aus Gruppe und zerstöre Sprite
            try {
              scene.circles.remove(sprite, true, true);
            } catch (e) {
              try { sprite.destroy(); } catch (e2) {}
            }
          });
        }
      });

      // optionaler Sound (safe play)
      try {
        if (soundOn && scene.sound && scene.sound.get('pop')) scene.sound.play('pop', { volume: 0.6 });
      } catch (e) { /* ignore */ }
    }

    function startGame(scene) {
      // ensure no leftover tweens or particles
      try { scene.tweens.killAll(); } catch (e) {}
      score = 0;
      if (scoreEl) scoreEl.textContent = 'Score: 0';
      running = true;
      centerMsg.style.display = 'none';
      infoEl.textContent = 'Spiel läuft';
      // spawn a few initial circles
      for (let i=0;i<3;i++) {
        if (scene.circles.getLength() < MAX_CIRCLES) spawnCircle(scene);
      }
    }

    function resetGame(scene) {
      // Stop spawning and animations
      running = false;
      spawnTimer = 0;
      score = 0;
      if (scoreEl) scoreEl.textContent = 'Score: 0';
      centerMsg.style.display = 'block';
      infoEl.textContent = 'Zurückgesetzt';

      // Kill all tweens (prevents hanging tweens)
      try { scene.tweens.killAll(); } catch (e) {}

      // Destroy all sprites in the group safely
      try {
        const children = scene.circles.getChildren().slice(); // copy
        children.forEach(c => {
          try { if (c && c.destroy) c.destroy(); } catch (e) {}
        });
        // clear group
        try { scene.circles.clear(true); } catch (e) {}
      } catch (e) { /* ignore */ }

      // remove any lingering particles
      try {
        scene.children.list.forEach(child => {
          if (child && child.texture && child.texture.key === 'particleDot' && child.destroy) {
            // don't destroy the texture itself, only particle emitters are destroyed above
          }
        });
      } catch (e) {}

      setTimeout(()=> infoEl.textContent = 'Tip: Klick Start', 1000);
    }
  </script>
</body>
</html>
