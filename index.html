<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Circle Blast</title>
  <style>
    html,body {
      margin:0;
      padding:0;
      width:100%;
      height:100%;
      overflow:hidden;
      background:#0b0b0f;
      color:#fff;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto;
    }

    #game-container {
      width:100%;
      height:100%;
      position:relative;
    }

    .ui {
      position:absolute;
      top:12px;
      left:12px;
      z-index:40;
    }

    .panel {
      background:#111217;
      padding:10px;
      border-radius:10px;
      display:flex;
      gap:8px;
      align-items:center;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    }

    .btn {
      background:#1f2937;
      border:none;
      color:white;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }

    .score {
      font-weight:700;
      padding:0 6px;
    }

    .timer {
      font-weight:700;
      opacity:0.95;
      padding:0 6px;
    }

    .center-msg {
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      text-align:center;
      opacity:0.95;
      pointer-events:none;
      z-index:20;
    }

    h1 { margin:0 0 6px 0; font-size:28px; }
    p { margin:0; opacity:0.9; }

    @media (max-width:520px){
      .panel{padding:8px}
      .score,.timer{padding:0 6px}
      .btn{padding:6px 8px}
      h1{font-size:22px}
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game-container"></div>

  <div class="ui">
    <div class="panel">
      <div class="score" id="score">Score: 0</div>
      <div class="timer" id="timer">Time: 30</div>
      <div class="score" id="highscore">Highscore: 0</div>
      <button class="btn" id="startBtn">Start</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
  </div>

  <div class="center-msg" id="centerMsg">
    <h1>Circle Blast</h1>
    <p>Kreise anklicken</p>
  </div>

  <script>
    // Einstellungen
    const MAX_CIRCLES = 6;
    const SPAWN_DELAY = 1200;
    const GAME_TIME = 30;
    const SPAWN_ATTEMPTS = 12;
    const PARTICLE_LIMIT = 8;
    const STORAGE_KEY = 'circle-blast-highscore-final';

    // Phaser Konfiguration
    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      width: Math.min(960, window.innerWidth),
      height: Math.min(640, window.innerHeight),
      backgroundColor: '#0b0b0f',
      scene: { preload, create, update }
    };

    let game = new Phaser.Game(config);

    function preload() {
      try { this.load.audio('pop', 'https://cdn.jsdelivr.net/gh/kripken/sound-effects/pop.mp3'); } catch(e){}
    }

    function create() {
      const scene = this;

      // UI-Elemente
      const scoreEl = document.getElementById('score');
      const timerEl = document.getElementById('timer');
      const highEl = document.getElementById('highscore');
      const centerMsg = document.getElementById('centerMsg');

      // Spielzustand
      let score = 0;
      let timeLeft = GAME_TIME;
      let running = false;
      let spawnEventLocal = null;
      let timerEventLocal = null;
      const activeEmitters = [];

      // Gruppe für Kreise
      scene.circles = scene.add.group();

      // Partikel-Textur einmalig erzeugen
      const g = scene.add.graphics();
      g.fillStyle(0xffffff, 1);
      g.fillCircle(3, 3, 3);
      g.generateTexture('particleDot', 6, 6);
      g.destroy();

      // Highscore helpers
      const loadHighscore = () => {
        const v = localStorage.getItem(STORAGE_KEY);
        return v ? parseInt(v, 10) : 0;
      };
      const saveHighscore = (v) => localStorage.setItem(STORAGE_KEY, String(v));
      const updateHighscoreDisplay = (v) => {
        if (highEl) highEl.textContent = 'Highscore: ' + v;
      };

      // ensure highscore visible immediately
      updateHighscoreDisplay(loadHighscore());

      // Resize-Fix: Szene an Fenster anpassen
      window.addEventListener('resize', () => {
        scene.scale.resize(Math.min(960, window.innerWidth), Math.min(640, window.innerHeight));
      });

      // Texture-Cache Helper
      const circleTexture = (size, colorInt) => {
        const key = `c_${size}_${colorInt}`;
        if (!scene.textures.exists(key)) {
          const gfx = scene.add.graphics();
          gfx.fillStyle(colorInt, 1);
          gfx.fillCircle(Math.round(size/2), Math.round(size/2), Math.round(size/2));
          gfx.generateTexture(key, size, size);
          gfx.destroy();
        }
        return key;
      };

      // Spawn-Funktion (mit Überlappungsprüfung)
      function spawnCircle() {
        if (!scene || !scene.scale) return;
        if (scene.circles.getLength() >= MAX_CIRCLES) return;

        const size = Phaser.Math.Between(40, 70);
        let chosen = null;
        for (let i=0;i<SPAWN_ATTEMPTS;i++) {
          const half = Math.round(size/2);
          const x = Phaser.Math.Between(half, scene.scale.width - half);
          const y = Phaser.Math.Between(half + 60, scene.scale.height - half);
          const overlaps = scene.circles.getChildren().some(existing => {
            const dx = existing.x - x;
            const dy = existing.y - y;
            const minDist = (existing.displayWidth + size) * 0.5 + 8;
            return (dx*dx + dy*dy) < (minDist * minDist);
          });
          if (!overlaps) { chosen = {x,y}; break; }
        }
        if (!chosen) return;

        const color = Phaser.Display.Color.RandomRGB().color;
        const textureKey = circleTexture(size, color);

        const sprite = scene.add.image(chosen.x, chosen.y, textureKey);
        sprite.setDisplaySize(size, size);
        sprite.setOrigin(0.5, 0.5);
        sprite._isBlasting = false;

        // Interaktiv pro Sprite
        sprite.setInteractive({ useHandCursor: true });
        const onPointer = () => {
          if (sprite._isBlasting) return;
          blast(sprite);
        };
        sprite.on('pointerdown', onPointer);

        // Lebenszeit-Timer
        sprite._lifeTimer = scene.time.delayedCall(
          Phaser.Math.Between(5000, 8000),
          () => {
            try {
              if (sprite && sprite.active && !sprite._isBlasting) {
                sprite.off('pointerdown', onPointer);
                try { sprite.destroy(); } catch(e){}
                try { scene.circles.remove(sprite, true, true); } catch(e){}
              }
            } catch(e){}
          }
        );

        scene.circles.add(sprite);
      }

      // Blast-Funktion: deaktivieren, tweenen, partikel, zerstören
      function blast(sprite) {
        if (!sprite || sprite._isBlasting) return;
        sprite._isBlasting = true;

        try {
          sprite.disableInteractive();
          if (sprite._lifeTimer && typeof sprite._lifeTimer.remove === 'function') {
            sprite._lifeTimer.remove();
          } else if (sprite._lifeTimer && typeof sprite._lifeTimer.destroy === 'function') {
            sprite._lifeTimer.destroy();
          }
          sprite._lifeTimer = null;
        } catch(e){}

        // Punkte
        try {
          score += 10;
          scoreEl.textContent = 'Score: ' + score;
        } catch(e){}

        // Highscore-Update
        try {
          const currentHigh = loadHighscore();
          if (score > currentHigh) {
            saveHighscore(score);
            updateHighscoreDisplay(score);
          }
        } catch(e){}

        const centerX = scene.scale.width / 2;
        const centerY = scene.scale.height / 2;

        try { scene.tweens.killTweensOf(sprite); } catch(e){}

        scene.tweens.add({
          targets: sprite,
          x: centerX,
          y: centerY,
          scaleX: 0.05,
          scaleY: 0.05,
          duration: 320,
          ease: 'Cubic.easeIn',
          onComplete: () => {
            // Partikel
            let particles;
            try {
              particles = scene.add.particles('particleDot');
              const emitter = particles.createEmitter({
                x: centerX, y: centerY,
                speed: { min: 80, max: 220 },
                angle: { min: 0, max: 360 },
                lifespan: 400,
                quantity: Math.min(6, PARTICLE_LIMIT),
                scale: { start: 1.0, end: 0 },
                blendMode: 'ADD'
              });
              activeEmitters.push(particles);

              scene.time.delayedCall(300, () => {
                try { emitter.stop(); } catch(e){}
                try { particles.destroy(); } catch(e){}
              });
            } catch(e){}

            // Sprite sicher entfernen
            try { sprite.off('pointerdown'); } catch(e){}
            try { if (sprite.active) sprite.destroy(); } catch(e){}
            try { scene.circles.remove(sprite, true, true); } catch(e){}
          }
        });

        // Sound (safe)
        try { if (scene.sound && scene.sound.get('pop')) scene.sound.play('pop', { volume: 0.6 }); } catch(e){}
      }

      // Safe destroy helper
      function safeDestroy(sprite) {
        if (!sprite) return;
        try {
          if (sprite._lifeTimer) {
            try { sprite._lifeTimer.remove(); } catch(e){ try { sprite._lifeTimer.destroy(); } catch(e){} }
            sprite._lifeTimer = null;
          }
          sprite.off && sprite.off('pointerdown');
          if (sprite.active) sprite.destroy();
          try { scene.circles.remove(sprite, true, true); } catch(e){}
        } catch(e){}
      }

      // Entferne alte Kreise, falls zu viele
      function removeOldCircles() {
        while (scene.circles.getLength() > MAX_CIRCLES) {
          const oldest = scene.circles.getChildren()[0];
          if (oldest) {
            try { oldest.off('pointerdown'); oldest.destroy(); } catch(e){}
            try { scene.circles.remove(oldest, true, true); } catch(e){}
          } else break;
        }
      }

      // Start / Reset / End Game mit sauberer Timer-Verwaltung
      let spawnEvent = null;
      let timerEvent = null;

      function startGame() {
        try { if (spawnEvent) { spawnEvent.remove(false); spawnEvent = null; } } catch(e){}
        try { if (timerEvent) { timerEvent.remove(false); timerEvent = null; } } catch(e){}
        try { scene.tweens.killAll(); } catch(e){}

        score = 0;
        timeLeft = GAME_TIME;
        scoreEl.textContent = 'Score: ' + score;
        timerEl.textContent = 'Time: ' + timeLeft;
        running = true;
        centerMsg.style.display = 'none';

        spawnEvent = scene.time.addEvent({
          delay: SPAWN_DELAY,
          loop: true,
          callback: () => {
            try { if (scene.circles.getLength() < MAX_CIRCLES) spawnCircle(); removeOldCircles(); } catch(e){}
          }
        });

        timerEvent = scene.time.addEvent({
          delay: 1000,
          loop: true,
          callback: () => {
            try {
              timeLeft--;
              timerEl.textContent = 'Time: ' + timeLeft;
              if (timeLeft <= 0) endGame();
            } catch(e){}
          }
        });

        for (let i=0;i<3;i++) {
          if (scene.circles.getLength() < MAX_CIRCLES) spawnCircle();
        }
      }

      function endGame() {
        running = false;
        try { if (spawnEvent) { spawnEvent.remove(false); spawnEvent = null; } } catch(e){}
        try { if (timerEvent) { timerEvent.remove(false); timerEvent = null; } } catch(e){}
        try { scene.tweens.killAll(); } catch(e){}

        centerMsg.style.display = 'flex';
        centerMsg.innerHTML = `<h1>Game Over</h1><p>Score: ${score}</p>`;
      }

      function resetGame() {
        running = false;
        score = 0;
        timeLeft = GAME_TIME;
        scoreEl.textContent = 'Score: 0';
        timerEl.textContent = 'Time: ' + GAME_TIME;

        try { if (spawnEvent) { spawnEvent.remove(false); spawnEvent = null; } } catch(e){}
        try { if (timerEvent) { timerEvent.remove(false); timerEvent = null; } } catch(e){}
        try { scene.tweens.killAll(); } catch(e){}

        try {
          const children = scene.circles.getChildren().slice();
          children.forEach(c => {
            try { c.off('pointerdown'); c.destroy(); } catch(e){}
          });
          scene.circles.clear(true);
        } catch(e){}

        try {
          activeEmitters.forEach(em => { try { em.destroy(); } catch(e){} });
          activeEmitters.length = 0;
        } catch(e){}

        centerMsg.style.display = 'flex';
        centerMsg.innerHTML = `<h1>Circle Blast</h1><p>Kreise anklicken</p>`;
      }

      // UI Buttons
      document.getElementById('startBtn').onclick = () => { if (!running) startGame(); };
      document.getElementById('resetBtn').onclick = () => { resetGame(); };

      // ensure timer and score visible immediately
      timerEl.textContent = 'Time: ' + timeLeft;
      scoreEl.textContent = 'Score: ' + score;
      updateHighscoreDisplay(loadHighscore());
    }

    function update() {
      // keine spawn-Logik hier; spawn wird per time event gesteuert
    }
  </script>
</body>
</html>

